---
description: This is a document that provides key PR reviewing as if they were a senior engineer
globs: 
---
# Key Learnings from Senior Engineer Code Review

1. **Leverage React Providers for Global State**

   - Using context providers (like the ExchangeRateContext) is an effective way to share data application-wide.
   - Encapsulating fetch logic within these providers or in dedicated hooks can simplify the rest of the codebase and improve maintainability.

2. **Separate Concerns Between Services and View Layer**

   - Keep the "services" layer focused on fetching and basic data transformations.
   - Avoid placing view-specific formatting (e.g., icon lookup or UI-ready strings) inside services—this leads to entanglement and potential reusability issues.
   - Move highly UI-related transforms (for example, mapping distribution types to icons) into a dedicated "lib" or the "view layer" (e.g., inside component utilities or dedicated functions).

3. **Use Dedicated Transformers Carefully**

   - Keep data transformations minimal and "model-oriented" in services, returning clean, typed data.
   - Perform purely presentational transformations (e.g., formatting numeric values or currency strings) within the view layer to reduce the likelihood of unnecessary re-fetching or tight coupling.

4. **Consider Creating Custom Hooks for Data Fetching**

   - Custom hooks (like "useUserBalance") can abstract away internal fetch logic and state management, similar to how "useSession" works in Next.js.
   - This pattern improves readability, makes the code more composable, and centralizes asynchronous logic behind a well-defined interface.

5. **Watch Out for Unnecessary Re-Renders and Side Effects**

   - Multiple data retrieval triggers can cause performance issues or data inconsistencies if not handled carefully.
   - Use checks to ensure that data is only fetched when needed. Employ memoization or context effectively to prevent repetitive fetch calls.

6. **Embrace a Layered Architecture**

   - A "service" layer for API interactions.
   - A "types/model" layer to define and represent data structures.
   - A "view/presentation" layer (React components) that handles all UI and formatting.
   - This structure is analogous to classic architectural patterns (e.g., "MVC") and ensures a more scalable and maintainable application over time.

7. **Balance Raw Data vs. Derived Data**

   - Keep a reference to the raw data (unformatted, untransformed) for potential debugging and logic needs.
   - Derive only what's necessary for display in the UI to avoid confusion or data loss.

8. **Consistent, Incremental Refinement**

   - Small refactors—such as relocating formatting functions and hooking into contexts—can make a significant difference in clarity and scalability.
   - Regular feedback loops and code reviews help solidify best practices and ensure the application remains well-structured as it grows.

9. **Minimal Client-Side Caching and Centralized Data**

   - Use React Context for global or shared data rather than implementing multiple fetch calls or storing redundant data in each component.
   - Avoid heavy local caching or memoization beyond what React already provides; excessive caching can introduce staleness bugs and complicate the code.
   - Fetch data once (for instance, in a provider) and rely on that single source of truth across your application.
   - Keep caching boundaries small: if data is needed by multiple components, lifting it into Context makes sense; otherwise, store it locally.
   - Be mindful of Next.js server/client boundaries; avoid turning everything into a client-side component, as it diminishes server-rendering advantages.

10. **Keep File and Folder Names Consistent**

    - Use a clear and consistent naming scheme for files and folders. For example, if you have a component for an item in a list, call it `TransactionListItem.tsx`, not `TransactionItem.tsx`.
    - For directories, use lowercase (e.g., `services`, `skeletons`) and consider capitalization for React component files.

11. **Use Descriptive Names That Reflect Purpose**

    - Choose intuitive front-end labels that reflect the actual functionality; avoid ambiguous terms.
    - If you have a button that exports data, label it "Export CSV" or "Export," rather than something vague like "export by year."

12. **DTO vs. "Plain" Types**

    - In service files, use type names like `SomethingApiResponse` or `SomethingDto` to indicate it's a direct mapping from an API payload.
    - For app-wide types (after you've transformed them), use straightforward names like `Transaction` or `Notification` that don't reference the API layer.

13. **Keep Function Names Action-Oriented**

    - Use verbs and descriptive phrases, like `markAllAsRead()` instead of `mark()`.
    - For fetching or transforming data, name them accordingly, e.g. `getTransactions()` or `transformTransaction()`.

14. **Use Short but Unambiguous Events or Handlers**

    - Handlers should be clear about which user action they handle, such as `onClickDeposit` or `handleDeposit`.
    - Keep them concise: `onClose`, `onClick`, `handleSubmit`, etc.

15. **Simplify Type Organization and API Integration**

    - Avoid using `.dto` files for API types unless specifically needed (e.g., authentication).
    - Maintain two primary files for each domain:
      1. A service file (e.g., `services/organization.service.ts`) handling API calls
      2. A types file (e.g., `types/organization.ts`) containing domain types and transformers
    - Use `any` type for raw API responses in service files since we don't control the API
    - Define clean, transformed types in the types directory that match our application's needs
    - Implement defensive transformers with null checks (e.g., `response.items || []`)
    - Keep service methods focused on API calls and basic error handling
    - Return transformed, application-specific types from service methods
    - Consider adding specific error classes for each service domain

16. **State Management Best Practices**

    - Be cautious with object dependencies in useEffect hooks
    - Remember that object reassignment (even with same values) triggers effects due to reference changes
    - Use additional state variables to prevent unnecessary re-fetching when dealing with session-like objects
    - Consider implementing fetch flags or other mechanisms to prevent duplicate API calls

17. **Type Naming Conventions**

    - Avoid prefixes like "Formatted" in type names
    - Use clear, domain-focused names (e.g., `Organization` instead of `FormattedOrganization`)
    - Keep type definitions close to their domain context
    - Use transformer functions to convert API data to application types

18. **Error Handling Philosophy**

    - Let errors bubble up naturally unless there's a specific need to handle them
    - Remove unnecessary try-catch blocks that just re-throw errors
    - Fail fast when data is invalid rather than trying to recover silently
    - Use try-catch only when:
      1. You can meaningfully recover from the error
      2. You need to transform the error type
      3. The API doesn't return data in the expected format

19. **Debugging and Logging**

    - Avoid committing console.log statements to production code
    - Use proper error tracking and monitoring tools instead
    - If logging is needed, implement structured logging with proper levels
    - Consider adding debug flags for development-only logging

20. **Component Naming Best Practices**

    - Name components based on their primary function, not their location or styling
    - Use action-oriented names for interactive components (e.g., `OrganizationSwitcher` instead of `OrganizationHeader`)
    - Consider the component's role in the larger application context
    - Examples:
      - ✅ `OrganizationSwitcher` (describes action/purpose)
      - ❌ `OrganizationHeader` (describes location/styling)
      - ✅ `NoteList` (describes content type)
      - ❌ `SidebarContent` (too generic/location-based)
